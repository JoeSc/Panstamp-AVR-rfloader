
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001e0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000002  00800100  00800100  00000254  2**0
                  ALLOC
  2 .stab         000006b4  00000000  00000000  00000254  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000082  00000000  00000000  00000908  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000030  00000000  00000000  0000098a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000003d  00000000  00000000  000009ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000296  00000000  00000000  000009f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000158  00000000  00000000  00000c8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000002e3  00000000  00000000  00000de5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000040  00000000  00000000  000010c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000122  00000000  00000000  00001108  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000a6  00000000  00000000  0000122a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  000012d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
	UDR0 = ch;
}
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a2 30       	cpi	r26, 0x02	; 2
  80:	b1 07       	cpc	r27, r17
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 69 00 	call	0xd2	; 0xd2 <main>
  88:	0c 94 ee 00 	jmp	0x1dc	; 0x1dc <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <getch>:

char getch(void)
{
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	40 e0       	ldi	r20, 0x00	; 0
  96:	50 e0       	ldi	r21, 0x00	; 0
  98:	15 c0       	rjmp	.+42     	; 0xc4 <getch+0x34>
	uint32_t count = 0;
	while(!(UCSR0A & _BV(RXC0))){
		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
		/* HACKME:: here is a good place to count times*/
		count++;
  9a:	2f 5f       	subi	r18, 0xFF	; 255
  9c:	3f 4f       	sbci	r19, 0xFF	; 255
  9e:	4f 4f       	sbci	r20, 0xFF	; 255
  a0:	5f 4f       	sbci	r21, 0xFF	; 255
		if (count > MAX_TIME_COUNT)
  a2:	21 32       	cpi	r18, 0x21	; 33
  a4:	81 ea       	ldi	r24, 0xA1	; 161
  a6:	38 07       	cpc	r19, r24
  a8:	87 e0       	ldi	r24, 0x07	; 7
  aa:	48 07       	cpc	r20, r24
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	58 07       	cpc	r21, r24
  b0:	49 f4       	brne	.+18     	; 0xc4 <getch+0x34>
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
  b2:	80 91 c0 00 	lds	r24, 0x00C0
  b6:	85 ff       	sbrs	r24, 5
  b8:	fc cf       	rjmp	.-8      	; 0xb2 <getch+0x22>
	UDR0 = ch;
  ba:	8e e2       	ldi	r24, 0x2E	; 46
  bc:	80 93 c6 00 	sts	0x00C6, r24
  c0:	8f ef       	ldi	r24, 0xFF	; 255
  c2:	08 95       	ret
}

char getch(void)
{
	uint32_t count = 0;
	while(!(UCSR0A & _BV(RXC0))){
  c4:	80 91 c0 00 	lds	r24, 0x00C0
  c8:	87 ff       	sbrs	r24, 7
  ca:	e7 cf       	rjmp	.-50     	; 0x9a <getch+0xa>
		{
			putch('.');
			return 0xff;
		}
	}
	return UDR0;
  cc:	80 91 c6 00 	lds	r24, 0x00C6
}
  d0:	08 95       	ret

000000d2 <main>:
void(* resetFunc) (void) = 0;

/* Some example here */

int main(void)
{
  d2:	8f 92       	push	r8
  d4:	9f 92       	push	r9
  d6:	af 92       	push	r10
  d8:	bf 92       	push	r11
  da:	cf 92       	push	r12
  dc:	df 92       	push	r13
  de:	ef 92       	push	r14
  e0:	ff 92       	push	r15
  e2:	0f 93       	push	r16
  e4:	1f 93       	push	r17
  e6:	cf 93       	push	r28
  e8:	df 93       	push	r29
//--	uint8_t ch;
//--	ch = MCUSR;
	MCUSR = 0;
  ea:	14 be       	out	0x34, r1	; 52

	WDTCSR |= _BV(WDCE) | _BV(WDE);
  ec:	80 91 60 00 	lds	r24, 0x0060
  f0:	88 61       	ori	r24, 0x18	; 24
  f2:	80 93 60 00 	sts	0x0060, r24
	WDTCSR = 0;
  f6:	10 92 60 00 	sts	0x0060, r1

//--	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
//--	if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
//--		app_start();  // skip bootloader

	UCSR0A = (1<<U2X0); //Double speed mode USART0
  fa:	82 e0       	ldi	r24, 0x02	; 2
  fc:	80 93 c0 00 	sts	0x00C0, r24
	UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*8L)-1);
 100:	80 e1       	ldi	r24, 0x10	; 16
 102:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = (F_CPU/(BAUD_RATE*8L)-1) >> 8;
 106:	10 92 c5 00 	sts	0x00C5, r1

	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
 10a:	88 e1       	ldi	r24, 0x18	; 24
 10c:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
 110:	86 e0       	ldi	r24, 0x06	; 6
 112:	80 93 c2 00 	sts	0x00C2, r24

	/* Enable internal pull-up resistor on pin D0 (RX), in order
	to supress line noise that prevents the bootloader from
	timing out (DAM: 20070509) */
	DDRD &= ~_BV(PIND0);
 116:	50 98       	cbi	0x0a, 0	; 10
	PORTD |= _BV(PIND0);
 118:	58 9a       	sbi	0x0b, 0	; 11


	/* set LED pin as output */
	LED_DDR |= _BV(LED);
 11a:	25 9a       	sbi	0x04, 5	; 4
 11c:	c0 e3       	ldi	r28, 0x30	; 48
 11e:	d0 e0       	ldi	r29, 0x00	; 0
	int i = '0';
    uint8_t ch = 0xff;
	while(1) {
        if (getch() == 'R')
        {
            *((uint8_t *)(RAMEND-52)) = 0x32;
 120:	72 e3       	ldi	r23, 0x32	; 50
 122:	87 2e       	mov	r8, r23
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
	UDR0 = ch;
 124:	67 e7       	ldi	r22, 0x77	; 119
 126:	96 2e       	mov	r9, r22
 128:	5f e6       	ldi	r21, 0x6F	; 111
 12a:	a5 2e       	mov	r10, r21
 12c:	42 e7       	ldi	r20, 0x72	; 114
 12e:	b4 2e       	mov	r11, r20
 130:	3b e6       	ldi	r19, 0x6B	; 107
 132:	c3 2e       	mov	r12, r19
 134:	2a e3       	ldi	r18, 0x3A	; 58
 136:	d2 2e       	mov	r13, r18
 138:	9d e0       	ldi	r25, 0x0D	; 13
 13a:	e9 2e       	mov	r14, r25
 13c:	8a e0       	ldi	r24, 0x0A	; 10
 13e:	f8 2e       	mov	r15, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 140:	08 ec       	ldi	r16, 0xC8	; 200
 142:	10 e0       	ldi	r17, 0x00	; 0


	int i = '0';
    uint8_t ch = 0xff;
	while(1) {
        if (getch() == 'R')
 144:	0e 94 48 00 	call	0x90	; 0x90 <getch>
 148:	82 35       	cpi	r24, 0x52	; 82
 14a:	39 f4       	brne	.+14     	; 0x15a <main+0x88>
        {
            *((uint8_t *)(RAMEND-52)) = 0x32;
 14c:	80 92 cb 08 	sts	0x08CB, r8
            resetFunc();  //call reset
 150:	e0 91 00 01 	lds	r30, 0x0100
 154:	f0 91 01 01 	lds	r31, 0x0101
 158:	09 95       	icall
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 15a:	80 91 c0 00 	lds	r24, 0x00C0
 15e:	85 ff       	sbrs	r24, 5
 160:	fc cf       	rjmp	.-8      	; 0x15a <main+0x88>
	UDR0 = ch;
 162:	90 92 c6 00 	sts	0x00C6, r9
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 166:	80 91 c0 00 	lds	r24, 0x00C0
 16a:	85 ff       	sbrs	r24, 5
 16c:	fc cf       	rjmp	.-8      	; 0x166 <main+0x94>
	UDR0 = ch;
 16e:	a0 92 c6 00 	sts	0x00C6, r10
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 172:	80 91 c0 00 	lds	r24, 0x00C0
 176:	85 ff       	sbrs	r24, 5
 178:	fc cf       	rjmp	.-8      	; 0x172 <main+0xa0>
	UDR0 = ch;
 17a:	b0 92 c6 00 	sts	0x00C6, r11
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 17e:	80 91 c0 00 	lds	r24, 0x00C0
 182:	85 ff       	sbrs	r24, 5
 184:	fc cf       	rjmp	.-8      	; 0x17e <main+0xac>
	UDR0 = ch;
 186:	c0 92 c6 00 	sts	0x00C6, r12
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 18a:	80 91 c0 00 	lds	r24, 0x00C0
 18e:	85 ff       	sbrs	r24, 5
 190:	fc cf       	rjmp	.-8      	; 0x18a <main+0xb8>
	UDR0 = ch;
 192:	d0 92 c6 00 	sts	0x00C6, r13
		putch('w');
		putch('o');
		putch('r');
		putch('k');
		putch(':');
		putch(i++);
 196:	9e 01       	movw	r18, r28
 198:	2f 5f       	subi	r18, 0xFF	; 255
 19a:	3f 4f       	sbci	r19, 0xFF	; 255
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 19c:	80 91 c0 00 	lds	r24, 0x00C0
 1a0:	85 ff       	sbrs	r24, 5
 1a2:	fc cf       	rjmp	.-8      	; 0x19c <main+0xca>
	UDR0 = ch;
 1a4:	c0 93 c6 00 	sts	0x00C6, r28
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 1a8:	80 91 c0 00 	lds	r24, 0x00C0
 1ac:	85 ff       	sbrs	r24, 5
 1ae:	fc cf       	rjmp	.-8      	; 0x1a8 <main+0xd6>
	UDR0 = ch;
 1b0:	e0 92 c6 00 	sts	0x00C6, r14
	}
}

void putch(char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 1b4:	80 91 c0 00 	lds	r24, 0x00C0
 1b8:	85 ff       	sbrs	r24, 5
 1ba:	fc cf       	rjmp	.-8      	; 0x1b4 <main+0xe2>
	UDR0 = ch;
 1bc:	f0 92 c6 00 	sts	0x00C6, r15
		putch('k');
		putch(':');
		putch(i++);
		putch('\r');
		putch('\n');
		if (i > '~')
 1c0:	2f 37       	cpi	r18, 0x7F	; 127
 1c2:	31 05       	cpc	r19, r1
 1c4:	14 f0       	brlt	.+4      	; 0x1ca <main+0xf8>
 1c6:	20 e3       	ldi	r18, 0x30	; 48
 1c8:	30 e0       	ldi	r19, 0x00	; 0
 1ca:	88 ee       	ldi	r24, 0xE8	; 232
 1cc:	93 e0       	ldi	r25, 0x03	; 3
 1ce:	f8 01       	movw	r30, r16
 1d0:	31 97       	sbiw	r30, 0x01	; 1
 1d2:	f1 f7       	brne	.-4      	; 0x1d0 <main+0xfe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1d4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1d6:	d9 f7       	brne	.-10     	; 0x1ce <main+0xfc>
 1d8:	e9 01       	movw	r28, r18
 1da:	b4 cf       	rjmp	.-152    	; 0x144 <main+0x72>

000001dc <_exit>:
 1dc:	f8 94       	cli

000001de <__stop_program>:
 1de:	ff cf       	rjmp	.-2      	; 0x1de <__stop_program>
